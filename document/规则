1,对于底层的数据结构的抽象和具体实现其实考虑两个方面，一个是如何方便上层模块的调用，另一个是方便底层的序列化
2,关于文件和目录的数据结构其实有很大的统一性，他们都是有一个目录项和一个簇链表组成的，不同之处在于：文件的这个
  簇链表里面的内容是文件的内容，而目录的这个簇链表里面又是一个目录项列表。如此，便构成了不断循环的树形结构目录。
3,整个Disk文件在系统运行过程中实际上始终是在内存中的，所谓的Load和store操作实际上是在内存之间的移动。正真操作系统
  层面的load/store操作实际上仅仅在init/exit系统的时候才会触发一次。
  而在所谓的"模拟"层面，当系统启动并完成初始化init过程之后，整个磁盘文件对应在内存中的高级数据结构已经创建了，当用户
  要更改磁盘的内容的时候直接操作的都是高级数据结构，并不会向Disk对象里面写入byte数组，这里提供一个命令来实现虚拟层面
  的把掉软盘或者关机之类会触发写入磁盘的命令，即flush，它会将高级数据结构序列化到各自byte数组里面，然后再汇总到Disk的
  大byte数组里面.
  但是有考虑到如果把Data部分的数据也一定的复写实在有点效率地下，所以，在DefaultData数组里面维护一个在上一次store操作
  至今被修改过的Sector的链表，当下次调用store指令的时候只讲这些扇区重写，并且把这个链表清空。并且这个链表应该是大小有
  上上限的，如果没有足够的剩余空间加载一个文件的话，还需要替换掉部分其他扇区，其实也就是内存管理的一部分。

4,Root分区里面记录根目录的条目数量的时候用的是数量，而非扇区，我想应该是这个条目数在某些情况下能够直接使用，比较方便
  在从数据结构上来讲，这个条目数*32/512必然是个整数，因为要是整个扇区。起码我这样去假设。
5,在Boot,Fat,RootDir,Data这些子块中，都同样有低级数据结构byte数组，完全是从Disk的byte数组的一部分拷贝，另一部分就是
  各个模块自定义的高级数据结构，在这两层数据结构之间必然存在转换关系，由低级向高级的转换过程就放在构造器里面，而高级
  数据结构向低级数据结构的转换放在一个store方法里面。
  关于数据结构的构建主要有两种情况，一种是已经定义了的磁盘文件，以文件的形式存在，通过IO加载到Disk的byte数据里面，然后
  逐层的从底向上的构建整个数据结构体系(这个时候主要用到构造函数)；还有一种情况是在代码里面直接构建高级的数据结构，最后在持久化到文件里面，这个
  时候和前者刚刚是相反的状况(这个时候只用到store方法)。另外无论哪一种在用户命令层面修改的时候都会部分的用到store方法。
  在初步实现阶段不用过多考虑创建Disk文件的情况
6,关于两个FAT分区，一个做备份，合适启动，暂时不考虑这个问题，就是说暂时始终使用FAT1分区

7,




