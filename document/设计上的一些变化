1，关于系统中目录的管理。
    一开始对这个问题没有进行深入的思考的详细的设计，后期在处理目录相关问题的时候有非常大的问题，现在重新设计一下这里的的逻辑
    1),根目录和普通目录仍然分开
    2),维护当前目录的数据结构是Deque<Item>对象，其他和当前目录相关操作都通过这个栈来实现。另外每次对目录的变更都要更新
        这个栈，而且栈里面所有Item的页表簇链任然统一由内存管理模块管理。
    3),每一个Item对象都应该有一个“绝对路径”的属性来表示其唯一性。显然，这个绝对路径在磁盘上是没有的是加载的过程中算出来的。
    4),注意一个坑，就是Item_Attr_Name是有空格补齐的。

2,关于系统中操作的粒度说明。
    Controller和DiskManager都有一些总控程序的味道，区分他们的粒度。尤其是要对文件的更改，涉及到对磁盘的各个分区的修改的操作
    都有manager来统一完成，而controller的直接任务就是操控manager。所以对于增删该的任务其实都内聚到了manager的方法里面。
    包括必要的store操作

3,关于store
    在做更改操作的时候必然要使用到store方法。忽然发现之前设计上又存在一个很大问题。
    对于Item对象，我单纯的从Root区或者Data区将字节数组赋值了出来，但是Disk并没有维持对这些游离的Item对象的引用，
    所以store的时候完全无从谈起。所以我现在的补救措施是：反向的，在Item对象中增加两个指针，指向的是该Item本身
    的自己数组在Root或者Data中的起始地值；另外还要设置一个标志位用来表明是Root还是Data。
