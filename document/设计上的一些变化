1，关于系统中目录的管理。
    一开始对这个问题没有进行深入的思考的详细的设计，后期在处理目录相关问题的时候有非常大的问题，现在重新设计一下这里的的逻辑
    1),根目录和普通目录仍然分开
    2),维护当前目录的数据结构是Deque<Item>对象，其他和当前目录相关操作都通过这个栈来实现。另外每次对目录的变更都要更新
        这个栈，而且栈里面所有Item的页表簇链任然统一由内存管理模块管理。
    3),每一个Item对象都应该有一个“绝对路径”的属性来表示其唯一性。显然，这个绝对路径在磁盘上是没有的是加载的过程中算出来的。
    4),注意一个坑，就是Item_Attr_Name是有空格补齐的。

2,关于系统中操作的粒度说明。
    Controller和DiskManager都有一些总控程序的味道，区分他们的粒度。尤其是要对文件的更改，涉及到对磁盘的各个分区的修改的操作
    都有manager来统一完成，而controller的直接任务就是操控manager。所以对于增删该的任务其实都内聚到了manager的方法里面。
    包括必要的store操作

3,关于store
    在做更改操作的时候必然要使用到store方法。忽然发现之前设计上又存在一个很大问题。
    对于Item对象，我单纯的从Root区或者Data区将字节数组赋值了出来，但是Disk并没有维持对这些游离的Item对象的引用，
    所以store的时候完全无从谈起。所以我现在的补救措施是：反向的，在Item对象中增加两个指针，指向的是该Item本身
    的自己数组在Root或者Data中的起始地值；另外还要设置一个标志位用来表明是Root还是Data。
    另外一个是区分item项的store和dir/file的store，前者是对32bit序列化到byte数组上，后者是将他们的扇区链持久化到Data分区中

4，涉及到虚拟内存的管理。
    还是考虑文件和目录的统一性。
    1),对于文件修改好理解。每一次访问，也就是edit命令，都要去执行load方法(查表，后加载)。每次保存，也就是save，先写到
      磁盘中去，然后再删除Data中的扇区表。
    2),对于目录类似的。一旦访问，也就是cd命令一经入，都应该改load(根目录常驻内存，不需要)。而且每次list命令，还要load。
      这点和文件有点不同。当修改了目录项的时候，除了将扇区链表持久化之后，还要删除Data中对应扇区表。
      对于目录还有一点必须想明白，对于cd命令的参数是多级目录跳转是否再每一次跳转都需要加载栈顶目录呢？
      答案是不需要，仅仅在cd命令执行的最后执行load就可以，因为只有最后的才是当前目录。

    比较麻烦的一点就是，这些操作都需要在对应的方法里面一一实现。

5,Data中的扇区号
    从2开始
